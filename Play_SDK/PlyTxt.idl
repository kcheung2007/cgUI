/*==========================================================================*\
||                                                                          ||
||  Copyright 1995 by Play Incorporated                                     ||
||  PLAY CONFIDENTIAL                                                       ||
||                                                                          ||
||  All Specifications subject to change.                                   ||
||                                                                          ||
||  FILE:       PlyTxt.idl                                                  ||
||                                                                          ||
||  DESCRIPTION:Interface description for creating and using anti-aliased   ||
||              text.                                                       ||
||                                                                          ||
||  INTERFACES : IPlayText                                                  ||
||               IPlayFont                                                  ||
||                                                                          ||
||  Written by Todd Sprague                                                 ||
||  (c) 1995 by Play Incorporated                                           ||
||  PLAY CONFIDENTIAL                                                       ||
||                                                                          ||
||  MODIFICATIONS:  1/13/96     Created                         T.Sprague   ||
||                                                                          ||
\*==========================================================================*/

//
// An interface for helping to find out what fonts are available, and what styles 
// they allow or support.
//
[
    local,
    object,
    uuid(8335e426-ab3b-11ce-8468-0000b468276b)
]
interface IPlayFontInfo : IUnknown
{
    import "unknwn.idl";
    import "wtypes.idl";

    // Get the name of this font.
    HRESULT GetName( [out,string] LPSTR pszName );

    // Get the pre-made sizes for this font.  If the table isn't big enough,
    // this will return E_INVALIDARG, and fill-in the first position in the 
    // table with the number of slots required.
    HRESULT GetSizes( DWORD *plaSize, DWORD lTableSize );

    // fill-in the DWORD with flag bits indicating which styles are allowed.
    // Will return E_NOTIMPL if no other styles are supported.
    HRESULT GetStyles( DWORD *plStyles );

    // fill-in the DWORD with flag bits indicating which extended styles are supported.
    // Will return E_NOTIMPL if no extended styles are supported.
    HRESULT GetExtendedStyles( DWORD *plExtStyles );

}

//
// The AA Text interface itself.
//

[
    local,
    object,
    uuid(8335e425-ab3b-11ce-8468-0000b468276b)
]
interface IPlayText : IUnknown
{
    import "unknwn.idl";
    import "wtypes.idl";
    import "gxlate.idl";

    // this returns an enumerator that will give back multiple IUnknown interfaces.
    // These interfaces in turn can be queried for the IPlayFont interface, through
    // which one can find out more about the available fonts.
    HRESULT EnumFonts( IEnumUnknown **ppiEnumUnk );

    // This will set the text to be drawn.  Calling this routine will invalidate any
    // AA masks that have been previously generated by this object.
    // The string is null-terminated.
    HRESULT SetText( [in,string] LPSTR pszText );

    // This will set the font to be used for the AA text.  If this makes an actual 
    // change, then it will invalidate any masks that have been generated.
    // The fontname is null-terminated.
    HRESULT SetFont( [in,string] LPSTR pszFontname, DWORD dwSize, DWORD dwStyle );

    // This will set an extended font style attribute.  These may vary on a font-by-font
    // basis, and the allowed extended styles can be examined in a IPlayFontInfo
    // interface.  If this causes actual changes, the AA text mask will be invalidated.
    HRESULT SetExtendedStyle( DWORD dwStyle, DWORD dwValue );

    // this routine will return a pointer to an IPlayFontInfo for the current font,
    // so the allowed styles and extended styles can be examined.
    HRESULT QueryFontInfo( IPlayFontInfo **ppiFontInfo );

    // find out the size of the rectangle required for current text in current font.
    // This can be called without the mask having been generated, and it will
    // not cause the mask to generated.  If it doesn't know the font yet, or no
    // text has been set, it will return E_FAIL, and both parts of the SIZE struct
    // will be zero.
    HRESULT GetSize( [out] SIZE *pSize );

    // find out the size of the rectangle required for part of current text in 
    // current font.  This can be called without the mask having been generated, 
    // and it will not cause the mask to generated.  If it doesn't know the font yet, or no
    // text has been set, it will return E_FAIL, and both parts of the SIZE struct
    // will be zero.  This will return the size of the rectangle needed to hold 
    // the text starting with start character, for len characters.
    HRESULT GetPartialSize( [in] DWORD start, [in] DWORD len, [out] SIZE *pSize );

    // This routine allows one to force the AA mask to be generated.  After this,
    // any of the following routines can be called without the mask having to be
    // re-generated.
    HRESULT ForceGenerate();

    // This sets the color that the text will be drawn in.
    HRESULT SetColor( DWORD dwColor );

    // This allows for setting the transparency level of the text.  (good for shadows)
    // 0 is totally transparent, 255 or higher is totally opaque.
    HRESULT SetTransparency( DWORD dwTrans );

    // This draws the current text into the given DC at the given position.
    // If the mask hasn't been generated yet, or if it has become invalid, then
    // this routine will cause the mask to be generated before it is drawn.
    HRESULT DrawToDC( HDC hDC, ULONG dx, ULONG dy );

    // This draws the current text into the given bitmap at the given position.
    // If the mask hasn't been generated yet, or if it has become invalid, then
    // this routine will cause the mask to be generated before it is drawn.
    HRESULT DrawToBitmap( IGXIntBitmap *piBitmap, ULONG dx, ULONG dy );

    // This draws the current text into the given DIB at the given position.
    // The DIB must be 24-bit.
    // If the mask hasn't been generated yet, or if it has become invalid, then
    // this routine will cause the mask to be generated before it is drawn.
    // (the LPVOID is really a (BITMAPINFOHEADER*) )
    HRESULT DrawToDIB( LPVOID pBMIH, unsigned char *pBits, ULONG dx, ULONG dy );

    // Release the memory used by the text mask.  Subsequent drawing calls
    // will have to generate the mask again.
    HRESULT ReleaseMask();

    // This will get the text to be drawn.
	// The string is NULL-terminated.
	// will return E_FAIL if the buffer isn't big enough.
	// The variable pointed to by pdwReqBufSize will filled-in with 
	// the length of the buffer required to hold the string (including 
	// NULL terminator).  dwBufSize is the size of YOUR buffer passed in pszBuffer.
	// The required size will always be filled-in, regardless of success.  The required
	// size may be zero if the object doesn't have any test yet.
    HRESULT GetText( [out] DWORD *pdwReqBufSize, [out,string] LPSTR pszBuffer, DWORD dwBufSize );

}

[
    local,
    object,
    uuid(8335e402-ab3b-11ce-8468-0000b468276b)
]
interface IPlayEditText : IUnknown
{
    import "unknwn.idl";
    import "wtypes.idl";

	HRESULT PutInWindow(HWND hWnd, int x, int y, int width, int height);

	BOOL	SetMaxCharacters(DWORD dwNumChars);

	BOOL	SetSize(SIZE *szText);

	HRESULT SetTextAttributes(LPSTR pszFontName, short fontSize, short fontStyle);

	HRESULT SetColor(DWORD dwNormalColor, DWORD dwHighColor, DWORD dwExciteColor, DWORD dwGhostColor);

	HRESULT SetText(LPSTR pszText);
	HRESULT GetText(LPSTR pszText, DWORD dwNumChars);

	BOOL	SetCaret(DWORD dwLocation);

	HRESULT SetEditType(DWORD dwType);

	void	UpdateRect(BITMAPINFOHEADER *pHeader, BYTE *pBits, RECT *pClip, POINT *pOfs);
	void	ExciteMe(BOOL bTurnOn);
	void	GhostMe(BOOL bTurnOn);

	void	GetSize(SIZE *sz);

	HRESULT	Reposition(int x, int y, int width, int height);

	HRESULT GetTextAttributes(LPSTR pszFontName, DWORD numChars, short *fontSize, short *fontStyle);
	HRESULT GetTextColors(DWORD *dwNormalColor, DWORD *dwHighColor, DWORD *dwExciteColor);

	HRESULT SetShowingText(DWORD dwPosition, BOOL bStart);

	DWORD	GetTextLength(void);

	HRESULT DrawToDC(HDC hDC, long x, long y);

	void	InvalidateCache(void);

	void	DisableMe(BOOL bTurnOn);

	void	MakeCache(BITMAPINFOHEADER *pHeader, BYTE *pBits, POINT *pOfs);

	void	DrawToDIB(BITMAPINFOHEADER *pHeader, BYTE *pBits, POINT *pOfs);

	// find out how big this text would be if its whole length were shown
	DWORD	GetTextPixelLength(void);

	// find out how wide in pixels the currently-visible text is.
	DWORD	GetTextPixelLengthShowing(void);

    // with this, the object will select/deselect itself.
    // for selection, set option to 1 to have it select all its text
    // for deselection set option to 1 for success, 0 for cancel.
    HRESULT Select( BOOL bSelect, DWORD dwOption );

}
